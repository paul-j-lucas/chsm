.\"
.\"     CHSM Language System
.\"     CHSM::event.3 -- event class manual page
.\"
.\"     Copyright (C) 1996-2013  Paul J. Lucas & Fabio Riccardi
.\"
.\"     This program is free software; you can redistribute it and/or modify
.\"     it under the terms of the GNU General Public License as published by
.\"     the Free Software Foundation; either version 2 of the License, or
.\"     (at your option) any later version.
.\" 
.\"     This program is distributed in the hope that it will be useful,
.\"     but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"     GNU General Public License for more details.
.\" 
.\"     You should have received a copy of the GNU General Public License
.\"     along with this program; if not, write to the Free Software
.\"     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
.\"
.TH \f3CHSM::event\f1 3 "January 21, 2010" "CHSM" "CHSM Language System"
.SH NAME
event \- CHSM event class
.SH SYNOPSIS
.ft CW
.nf
namespace Concurrent_Hierarchical_State_Machine {

    class event {
    public:
        void operator()();
        template<typename EventClass> bool is_type() const;
        char const* name();
    protected:
        struct param_block {
            param_block( event const& );
            virtual ~param_block();
        };
    };

    class \f2user\fP_event : public event {
    public:
        struct param_block : event::param_block {
            \f2parameter declarations\fP
            param_block( event const& );
            virtual ~param_block();
        };
        void operator()( \f2parameter declarations\fP );
        param_block* operator\->();

        // inherited
        char const* name();
    };

    bool operator==( event const&, event const& );
    bool operator!=( event const&, event const& );
}
.fi
.ft 1
.SH DESCRIPTION
Instances of the \f(CWevent\f1 class, or classes derived therefrom,
cause transitions to occur in a CHSM.
.SH event
The base event class.
It is the base class for all user-specified events;
it is also used directly for \f(CWenter()\f1 and \f(CWexit()\f1 events.
.SS "Member Functions"
.IP "\f(CWvoid operator()()\f1"
Broadcasts the event.
(See \f2user\f1\f(CW_event::operator()()\f1 below for more information.)
.IP "\f(CWtemplate<typename EventClass> bool is_type()\f1"
Returns \f(CWtrue\fP only if the event is of the given event class.
.IP "\f(CWchar const* name()\f1"
Returns the name of the event.
.SH "\f2user\f(CW_event\f1"
A \f4user_event\f1 is a class generated by the
.BR chsmc (1)
compiler for user-specified events.
For example,
a user-specified event \f(CWalpha\f1 has a class named \f(CWalpha_event\f1
generated for it.
.PP
User events may have parameters.
The \f(CWparam_block\f1 data members are the parameters of the event
plus all the parameters of all base events, if any, via inheritance,
taken from event declarations in a CHSM description by the
.BR chsmc (1)
compiler.
For derived events,
parameters are inherited in base-to-derived order.
.IP "\f(CWvoid operator()( \f2parameter declarations\fP )\f1"
Broadcasts the event with the specified parameters, if any.
.IP "\f(CWparam_block* operator\->()\f1"
Returns a reference to the parameter named on the right-hand-side.
.SH GLOBAL FUNCTIONS
.IP "\f(CWbool operator==( event const&, event const& )\f1"
.IP "\f(CWbool operator!=( event const&, event const& )\f1"
Returns \f(CWtrue\f1 only if the two given events are equal, or not equal,
respectively.
Because there is a single instance of each event per CHSM,
these functions test
.I identity
rather than equality;
hence two events of the same name from different instances of a CHSM
will not compare equal.
.SH SEMANTICS
.SS "Broadcasting"
Broadcasting an event that is already ``in progress'' does nothing;
the event is not rebroadcast.
Broadcasting a base event of an event already ``in progress'' does nothing.
.SS "Preconditions"
A precondition for an event
is the logical-and of all base event preconditions, if any,
evaluated in base-to-derived order.
Evaluation is ``short-circuited'' via the traditional semantics
of the C++ \f(CW&&\f1 operator.
If a precondition is not satisfied,
the event is not broadcast.
.SS "Finding Transitions"
After an event has satisfied its precondition,
all transitions on the given event out of currently-active states
have their conditions, if any, evaluated.
For derived events,
transitions are inherited in derived-to-base order so that transitions on
derived events will dominate those on base events.
.SH EXAMPLE
.ft CW
.nf
#include <iostream>
using namespace std;

%%
chsm my_machine is {
    event alpha;
    event<alpha> beta( int n );
    event<beta> gamma( char const *message );

    state x {
        alpha -> y %{
            alpha();                    // in progress -- does nothing
        %};
    }
    state y {
        beta -> z %{
            alpha();                    // does nothing since beta is-an alpha
            cout << beta->n << endl;    // access parameter
        %};
    }
    state z {
        gamma -> x %{
            cout << gamma->n << endl;   // inherited parameter
            cout << gamma->message << endl;
        %};
    }
}

%%
int main() {
    my_machine m;
    m.alpha();                          // broadcast alpha

    my_machine::alpha_event *e;         // example of generated event class
    e = &m.beta;                        // legal since beta is-an alpha

    if ( my_machine::beta_event *b = dynamic_cast<machine::beta_event*>(e) )
        (*b)( 42 );                     // broadcast beta with parameter

    m.gamma( 42, "hello, world" );      // inherited parameters
}
.ft 1
.fi
.SH SEE ALSO
.BR chsmc (1),
.BR CHSM::state (3),
.BR chsm-c++ (4)
.SH AUTHORS
Paul J. Lucas
.RI < paul@lucasmail.org >
.br
Fabio Riccardi
.RI < fabio.riccardi@mac.com >
.\" vim:set et sw=4 ts=4:
