/*
**      CHSM Language System
**      State.java -- Run-Time library implementation
**
**      Copyright (C) 2004-2018  Paul J. Lucas & Fabio Riccardi
**
**      This program is free software; you can redistribute it and/or modify
**      it under the terms of the GNU General Public License as published by
**      the Free Software Foundation; either version 3 of the License, or
**      (at your option) any later version.
**
**      This program is distributed in the hope that it will be useful,
**      but WITHOUT ANY WARRANTY; without even the implied warranty of
**      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**      GNU General Public License for more details.
**
**      You should have received a copy of the GNU General Public License
**      along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package CHSM;

///////////////////////////////////////////////////////////////////////////////

/**
 * A {@code State} is the simplest kind of state in a machine: it has no child
 * states.  A state can either be active (in the state) or inactive (not in the
 * state); a state may have a parent, and enter/exit actions.
 * <p>
 * The {@code State} class can be extended either to add additional data
 * members and methods, or to alter its behavior upon being entered or exited.
 *
 * @author Paul J. Lucas
 */
public class State {

    ////////// public /////////////////////////////////////////////////////////

    /**
     * An {@code Action} is a method that is optionally called upon entrance to
     * or exit from a {@link State}.
     */
    public interface Action {
        /**
         * Performs an action by executing some user code.  You should never
         * need to call this explicitly.  It is called via code generated by
         * the CHSM-to-Java compiler.
         *
         * @param s The {@link State} that is being entered or exited.
         * @param trigger The {@link Event} that triggered the transition.
         */
        void exec( State s, Event trigger );
    }

    /**
     * Constructs a {@code State}.
     * 
     * When deriving a class from {@code State} in the declarations section in
     * a CHSM description (<tt>.chsmj</tt>) file, the &quot;macros&quot;
     * {@code CHSM_STATE_ARGS} and {@code CHSM_STATE_INIT} can be used to avoid
     * having to deal with the many constructor arguments, e.g.:
     * <pre>
     *  class Place extends CHSM.State {
     *      public Place( CHSM_STATE_ARGS ) {
     *          super( CHSM_STATE_INIT );
     *          // ...
     *      }
     *      // ...
     *  }</pre>
     *
     * @param m The {@link Machine} this state belongs to.
     * @param name The name of this state.
     * @param p The {@link Parent} of this state.
     * @param enterAction The action to be performed upon entrance to this
     * state, or {@code null} if none.
     * @param exitAction The action to be performed upon exit from this state,
     * or {@code null} if none.
     * @param enterEvent The {@link Event} to be broadcast upon entrance to
     * this state.
     * @param exitEvent The {@link Event} to be broadcast upon exit from this
     * state.
     */
    public State( Machine m, String name, Parent p, Action enterAction,
                  Action exitAction, Event enterEvent, Event exitEvent ) {
        machine_     = m;
        parent_      = p;
        name_        = name;
        enterAction_ = enterAction;
        exitAction_  = exitAction;
        enterEvent_  = enterEvent;
        exitEvent_   = exitEvent;
    }

    /**
     * Gets whether this state is active.
     *
     * @return Returns {@code true} only if the state is active.
     */
    public final boolean active() {
        return (state_ & S_ACTIVE) != 0;
    }

    /**
     * Clears the history for all child clusters of a cluster, recursively.
     * Plain states have neither children nor a history.  Placing this function
     * here is a wart on the design; by having it here, however, run-time
     * type-identification ({@code instanceof}) can be avoided.
     */
    public void deepClear() {
        // do nothing
    }

    /**
     * Gets the {@link Machine} this state belongs to.
     *
     * @return Returns said {@link Machine}.
     */
    public final Machine machine() {
        return machine_;
    }

    /**
     * Gets the name of this state.
     *
     * @return Returns said name.
     */
    public final String name() {
        return name_;
    }

    /**
     * Gets the parent {@link Cluster} or {@link Set} this state belongs to.
     *
     * @return Returns the parent or {@code null} if none.
     */
    public final Parent parent() {
        return parent_;
    }

    ////////// package ////////////////////////////////////////////////////////

    static final int S_INACTIVE         = 0x00;
    static final int S_ACTIVE           = 0x01;

    /**
     * This is used to prevent making more than one nondeterministic transition
     * from the same state.  See the comments in {@code Event.java} for more
     * information.
     */
    static final int S_ACTIVE_DISABLED  = 0x02 | S_ACTIVE;

    /** The state of this state. */
    int state_;

    ////////// protected //////////////////////////////////////////////////////

    /**
     * Enters a state.
     * 
     * If this state's parent state (if any) isn't active, enter it first.  The
     * event <code>$enter(</code><i>state</i><code>)</code> is broadcast and
     * the state's enter-action block is executed, if any.
     * <p>
     * When overriding in a derived class, the form <i>must</i> be:
     * <pre>
     *  public boolean enter( Event trigger, State fromChild ) {
     *      if ( !super.enter( trigger, fromChild ) )
     *          return false;
     *      // ... new functionality here ...
     *      return true;
     *  }</pre>
     *
     * @param trigger The {@link Event} that triggered the transition.
     * @param notUsed Not used here.
     * @return Returns {@code true} only if the state was actually entered,
     * i.e., it wasn't already active.
     * @see #exit(Event,State)
     */
    protected boolean enter( Event trigger, State notUsed ) {
        if ( active() )
            return false;
        if ( parent_ != null )
            if ( !parent_.active() ) {
                //
                // If we are being entered from another state directly
                // (bypassing our parent), we have to enter our parent first.
                // (This is the only place where the second argument to enter()
                // is not null.)
                //
                parent_.enter( trigger, this );
                //
                // In the case where our parent is a set, it will also have
                // entered all of its child states (including us).  We must
                // therefore check for this by seeing if we're active now: if
                // so, return and do not enter ourselves again.
                //
                if ( active() )
                    return false;
            } else {
                //
                // Otherwise, we have to ask our parent for permission to be
                // entered.  (See the comment in Cluster.switchActiveChildTo()
                // for further details.)
                //
                if ( !parent_.switchActiveChildTo( this ) )
                    return false;
            }

        if ( (machine_.debugState_ & Machine.DEBUG_ENTER_EXIT) != 0 )
            machine_.echo( "entering : " + name() ).endl();

        state_ = S_ACTIVE;

        //
        // For this state, broadcast entered(this), but only if there are any
        // transitions on it.  The value for the enterEvent_ pointer is
        // determined by the CHSM-to-Java compiler.
        //
        if ( enterEvent_ != null )
            enterEvent_.broadcast( null );

        //
        // Perform the enter action resulting from an "upon enter" statement,
        // if any.  The value for the enterAction_ pointer is determined by the
        // CHSM-to-Java compiler.
        //
        if ( enterAction_ != null )
            enterAction_.exec( this, trigger );

        return true;
    }

    /**
     * Exits a state.
     * 
     * If the &quot;to&quot; state doesn't have this state's parent state (if
     * any) as an ancestor, exit this state's parent state first.  The event
     * <code>$exit(</code><i>state</i><code>)</code> is broadcast and the
     * state's exit-action block is executed, if any.
     * <p>
     * When overriding in a derived class, the form <i>must</i> be:
     * <pre>
     *  public boolean exit( Event trigger, State to ) {
     *      if ( !super.exit( trigger, to ) )
     *          return false;
     *      // ... new functionality here ...
     *      return true;
     *  }</pre>
     *
     * @param trigger The {@link Event} that triggered the transition.
     * @param to If not {@code null}, the state to transition to.
     * @return Returns {@code true} only if the state was actually exited,
     * i.e., it wasn't already active.
     * @see #enter(Event,State)
     */
    protected boolean exit( Event trigger, State to ) {
        if ( !active() )
            return false;
        state_ = S_INACTIVE;

        if ( (machine_.debugState_ & Machine.DEBUG_ENTER_EXIT) != 0 )
            machine_.echo( "exiting  : " + name() ).endl();

        //
        // For this state, broadcast exited(this), but only if there are any
        // transitions on it.  The value for the exitEvent_ reference is
        // determined by the CHSM-to-Java compiler.
        //
        if ( exitEvent_ != null )
            exitEvent_.broadcast( null );

        //
        // Perform the exit action resulting from an "upon exit" statement, if
        // any.  The value for the exitAction_ reference is determined by the
        // CHSM-to-Java compiler.
        //
        if ( exitAction_ != null )
            exitAction_.exec( this, trigger );

        if ( to != null && parent_ != null ) {
            //
            // The "to" state argument is supplied only to the "from" state
            // being exited directly.  It means we are responsible for ensuring
            // our parent state is exited if necessary.  To do this, check the
            // ancestors of the "to" state to see if one of them is our parent.
            // If it is, nothing needs to be done; if not, then we must force
            // our parent to exit.
            //
            State ancestor = to.parent_;
            while ( ancestor != null && ancestor != parent_ )
                ancestor = ancestor.parent_;
            if ( ancestor == null ) {
                //
                // Our parent is not an ancestor of the "to" state: force it to
                // exit.
                //
                parent_.exit( trigger, to );
            }
        }

        return true;
    }

    ////////// private ////////////////////////////////////////////////////////

    /** The {@link Machine} this state belongs to. */
    private final Machine machine_;

    /** The state's name. */
    private final String name_;

    /** The {@link Parent} of this state or {@code null} if none. */
    private final Parent parent_;

    /** The enter action or {@code null} if none. */
    private final Action enterAction_;

    /** The exit action or {@code null} if none. */
    private final Action exitAction_;

    /** The enter event or {@code null} if none. */
    private final Event enterEvent_;

    /** The exit event or {@code null} if none. */
    private final Event exitEvent_;
}

///////////////////////////////////////////////////////////////////////////////
/* vim:set et sw=4 ts=4: */
